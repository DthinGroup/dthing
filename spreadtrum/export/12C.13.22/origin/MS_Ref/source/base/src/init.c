/****************************************************************************** ** File Name:      init.c                                                    * ** Author:         Richard Yang                                              * ** DATE:           04/02/2002                                                * ** Copyright:      2002 Spreatrum, Incoporated. All Rights Reserved.         * ** Description:    This file defines the basic operation interfaces of       * **                 serrial device. It manages create, send, receive          * **                 interface of serrial port.                                * ****************************************************************************** ****************************************************************************** **                        Edit History                                       * ** ------------------------------------------------------------------------- * ** DATE           NAME             DESCRIPTION                               * ** 04/02/2002     Richard.Yang     Create.                                   * ** 06/03/2002     Xueliang.Wang    Modify according to new standard.         * ** 09/04/2003     Zhemin.Lin       Modify SCI_InitRef                        * ** 09/16/2003     Xueliang.Wang    Modify CR4013                             * ** 09/24/2003     Xueliang.Wang    Modify CR4916                             * ** 12/31/2003     Zhemin.Lin       Modify CR6659                             * ** 12/07/2004     Benjamin.Wang    Modify CR17118                            * ** 08/28/2010     Haifeng.yang     Modify                                    * ** 11/03/2010     fei.zhang           Add DSP USB Log function       * ******************************************************************************//**---------------------------------------------------------------------------* **                         Dependencies                                      * **---------------------------------------------------------------------------*/#include "ms_ref_base_trc.h"#include "ref_tasks_def.h"#include "init.h"#include "version.h"#include "power.h"#include "efs.h"        #include "doidleonpage.h"#include "tb_dal.h"#include "ref_param.h"#include "atc_sleep.h"#include "os_param.h"#include "sys_time_ext.h"#include "boot_mode.h"#include "bsd.h"#include "xsr_partition.h"#include "oscfg.h"#include "layer1_engineering.h"#include "mem_prod.h"#include "power_manager.h"#include "dal_power.h"#include "iram_mgr.h"#include "chip_init_drvapi.h"#include "img_dec_interface.h"#include "atc_port.h"#ifndef WIN32#include "deepsleep_drvapi.h"#include "driver_export.h"#include "run_mode.h"#include "diag.h"#include "task_monitor.h"#include "sci_ftlmnt_Engin.h"#include "sci_log.h"#include "dal_dcamera.h"#include "audio_config.h"#include "threadx_assert.h"#include "mux_driver.h"#include "task_monitor.h"#include "isp_service.h"#include "prod_param.h"#include "gpio_prod_api.h"#include "chip_drv_init.h"#include "char_dev.h"#ifdef UMEM_SUPPORT#include "flash.h"#include "umem_bsd.h"#endif#endif /* #ifndef WIN32 */#ifdef DSP_USB_LOG#include "dsp_log.h"#endif#ifdef IMG_EDITER_SUPPORT#include "img_proc.h"#endif#ifdef AUTOTEST_DEVICE_SUPPORT#include "autotest_device.h"#endif/**---------------------------------------------------------------------------* **                         Debugging Flag                                    * **---------------------------------------------------------------------------*/uint32 SCI_InitLogSaveTask(void);/*lint -esym(752, SCI_InitLogSaveTask)*//**---------------------------------------------------------------------------* **                         Compiler Flag                                     * **---------------------------------------------------------------------------*/#ifdef   __cplusplus    extern   "C"     {#endif/**---------------------------------------------------------------------------* **                         Constant Variables                                * **---------------------------------------------------------------------------*///lin.liu. CR12921.// // When it is non-zero, enable the nvitem cache feature, and can set the EFS priority//     to lowest.// If it is zero, disable the nvitem cache feature, and shouldn't set the EFS priority// lower than MMI to avoid the EFS queue full( for we support asynchronous optr )./////**---------------------------------------------------------------------------* **                         Global Variables                                  * **---------------------------------------------------------------------------*///record the init statusLOCAL INIT_STATUS_E s_init_status = STATUS_START_INIT;extern const char * SCI_GetRtosCompileDate(void);extern const char * GetRefCompileDate(void);#if defined(PRODUCT_DM)    extern uint32 SCI_InitRtosBottomHalf( void );#endif#ifdef CMMB_SUPPORT#ifndef WIN32extern void DTLRFVT_ThreadInit(void);extern void MTV_InitVLogFlag(void);#endif#endif#ifdef DEMOD_HW_INNOFIDEI#ifndef WIN32extern int INNO_DoDemodLowPowerMode(void);#endif#endif/*attention!!  the api for td l1c is hard to be called, so define the MACOR directly  this adress should be keep same with l1c's defination  *///#ifdef FPGA_VERIFICATION//#define DMDSP_LOAD_ADDRESS        0x11C20040//#else#define DMDSP_LOAD_ADDRESS          0x20000//#endif#define PROD_INIT_AFTER_USER_IMAGE  0x01/**---------------------------------------------------------------------------* **                     Local Function Prototypes                             * **---------------------------------------------------------------------------*/LOCAL void ShowVersionInfo(void);/*****************************************************************************/// Description :    Create reference tasks.// Global resource dependence : // Author :         Xueliang.Wang// Note :/*****************************************************************************/LOCAL int CreateRefTasks(uint32 mode);/**---------------------------------------------------------------------------* **                         Function Definitions                              * **---------------------------------------------------------------------------*//*****************************************************************************/// Description :    get the init status// Global resource dependence : // Author :         // Note :/*****************************************************************************/PUBLIC INIT_STATUS_E INIT_GetInitStatus(void){    return s_init_status;}/*****************************************************************************/// Description :    set the init status// Global resource dependence : // Author :         // Note :/*****************************************************************************/PUBLIC void INIT_SetInitStatus(INIT_STATUS_E status){    s_init_status = status;}/******************************************************************************/// Description: // Dependence: // Author:        Haifeng.Yang// Note:/******************************************************************************/LOCAL uint32 _INIT_CopyImage(void){    BSD_HANDLE         pHandle;    BSD_DEVICE         pDev;    //#ifndef FPGA_VERIFICATION /* for jtag debug */    if(CHIP_DetectMemType())    {        char * bml_name;        if (MEM_HasLoadImage())        {#if defined(VM_SUPPORT)            bml_name = BML_KERNELOS2_NAME;#else            bml_name = BML_DEMANDONOS_NAME;#endif            // Load Demandon OS image !NOW!            if ((SCI_NULL == MEM_GetUserImageAddress()) ||                   (MEM_GetUserImageSize() == 0) ||                      (BSD_SUCCESS != BSD_Open (bml_name, BSD_GENERIC_READ, &pHandle)) ||                      (BSD_SUCCESS != BSD_GetDeviceByHandle (pHandle, &pDev)) ||                      (MEM_GetUserImageSize() > ((pDev.TotScts)*(pDev.SectorSize))) ||                      (BSD_SUCCESS != BSD_Read (pHandle,                                        0,                                         (MEM_GetUserImageSize()/pDev.SectorSize + 1),                                        (void *)MEM_GetUserImageAddress ())))            {                SCI_PASSERT (0, ("\r\nPlease download user image again"));/*assert verified*/            }        }        //copy dsp code image        if( BSD_SUCCESS == BSD_Open(BML_DSPCODE_PART_NAME, BSD_GENERIC_READ, &pHandle) )        {            if( BSD_SUCCESS == BSD_GetDeviceByHandle(pHandle, &pDev) )            {                if( BSD_SUCCESS != BSD_Read(pHandle, 0, pDev.TotScts, (void*)( DMDSP_LOAD_ADDRESS)) )                {                    //not recoverable                    SCI_PASSERT (0, ("\r\nPlease download user image again"));/*assert verified*/                }            }        }    }//#endif    return SCI_SUCCESS;}/*****************************************************************************/// Description :    Save HW restart condition.//                  It is maybe by PowerButton, Charge, Alarm or none.// Global resource dependence : // Author :         Xueliang.Wang// Note :/*****************************************************************************/LOCAL void SaveHWRestartCondition(void){    uint32  condition;    uint32  tmp;    tmp = POWER_GetResetMode();    if(tmp&MCU_MODE_USB)     {        /*mcft by usb */        RM_SetDloaderMode(1);    }    // Check if it is PowerButton    if (SCI_TRUE == CheckPowerButtonState ())    {        condition = RESTART_BY_POWER_BUTTON;    }    else    {        // Check if it is Alarm.        if (CheckRTCState () & BIT_4)        {            condition = RESTART_BY_ALARM;        }        else        {            // Check if it is Charge.            if( CHGMNG_IsChargeConnect() )             {                condition = RESTART_BY_CHARGE;            }            else            {                condition = RESTART_BY_NONE;            }        }    }    POWER_SetRestartCondition(condition);}extern int CPL_GPS_ComInit(uint32 BaudRate);/*****************************************************************************/// Description :    Save sw restart condition.//                  It is maybe by software, assert back, cft mode.// Global resource dependence : // Author :         Xueliang.Wang// Note :/*****************************************************************************/LOCAL void SaveSWRestartCondition(void){    uint32  condition;    uint32  tmp;    tmp = POWER_GetResetMode();    tmp &= ~MCU_MODE_USB;    /*get restartcondition first!*/    condition = POWER_GetRestartCondition();    if(ASSERT_BACK_MODE == tmp)    {        condition = RESTART_BY_ASSERT;    }    else if(NORMAL_MODE != tmp)    {        condition = RESTART_BY_SOFTWARE;        switch(tmp){            /* In calibration mode.*/            case TD_CALIBRATION_MODE:                {#ifndef WIN32                        BOOT_SetResetMode (CALIBRATION_MODE);                    RM_HandlePowerResetMode(TD_CALIBRATION_MODE);#endif                    }            case CALIBRATION_MODE:      /*lint !e825*//*lint !e616*/                {                    RM_SetCalibrationMode(SCI_TRUE);                }                break;            case TD_CALIBRATION_POST_MODE:                {#ifndef WIN32                        BOOT_SetResetMode (CALIBRATION_POST_MODE);                    RM_HandlePowerResetMode(TD_CALIBRATION_POST_MODE);#endif                    }            case CALIBRATION_POST_MODE:        /*lint !e825*//*lint !e616*/                {                    RM_SetCalibrationPostMode(SCI_TRUE);                    SCI_Calibration_EnableDeepSleep(0);    //disable arm deep sleep.                }                break;            case BOOT_RESET_MODE :                {                #ifndef WIN32                    HAL_MCUBootReset();                #endif                }                break;            case PIN_TEST_MODE :                {                    RM_SetPinTestFlag(SCI_TRUE);    /*in production-test mode.*/                }                break;            case IQC_TEST_MODE:                {                    RM_SetIQCTestFlag(SCI_TRUE);                    RM_SetPinTestFlag(SCI_TRUE);                }                break;            case TD_CALIBRATION_POST_NO_LCM_MODE:                {#ifndef WIN32                        BOOT_SetResetMode (CALIBRATION_POST_NO_LCM_MODE);                    RM_HandlePowerResetMode(TD_CALIBRATION_POST_NO_LCM_MODE);#endif                    }            case CALIBRATION_POST_NO_LCM_MODE:       /*lint !e825*//*lint !e616*/                {                    RM_SetCalibrationPostNoLcmMode(SCI_TRUE);                    SCI_Calibration_EnableDeepSleep(0);    //disable arm deep sleep.                }                break;            default:                break;        }    }    POWER_SetRestartCondition(condition);}/*****************************************************************************/// Description :    Initialize reference resource according to mode.// Global resource dependence : // Author :         Xueliang.Wang// Note :/*****************************************************************************/PUBLIC uint32 SCI_InitRef(uint32 mode){    uint32 tmp;#ifndef WIN32        uint8              debug_phy_port;    uint8              data_phy_port;    SIO_CONTROL_S   m_dcb;#endif    uint32            iram_area_cnt = 0;      IRAM_AREA *     area_p = SCI_NULL;    POWER_SetMsStatus(POWER_MS_STATUS_INIT);#ifndef WIN32    TM_SendInitRequest(); //kevin.wang@0719    // Phase2 of chip driver intialization. It initializes driver modules     // before refbase confirms powering on.    CHIPDRV_InitOnPhase2 ();#endif#ifndef WIN32    CharDev_Initialize();#endif    // Diag init;     InitDiag();  //Added by Johnson.sun 2006/10/09    // Init BSD interface    BSD_Initialize ();#ifdef NANDBOOT_SUPPORT    if(CHIP_DetectMemType())    {      // Init XSR #if !defined(WIN32)    SCI_FTLMnt_Init ();#endif    }#endif    // Init EFS Module here, and EFS_Task not init it now.    // So we can make sure that the EFS module has been init-ed when other tasks     // call EFS API(include NVITEM API)    .        EFS_Init();    // Now we check uart tx fifo to set run mode    RM_GetRunModeResponse ();    SaveSWRestartCondition();#ifndef WIN32    // The parameter has been download to the module,    // So it can read successfully, needn't write data to flash at here.        // These two functions must be called after EFS_Init().    OSPARAM_InitOsParam();    REFPARAM_InitRefParam();    PROD_InitProdParam();#endif#ifndef TDPS_UEIT_ARM_L1SIM_HSDPA    if( L1API_DOWNLOADPARAM_GetDSPLogSwitch() != FALSE)    {        if( POWER_IsCalibrationResetMode() )        {            DSPLogUARTSwitchOff ();        }        else        {            DSPLogUARTSwitchOn ();        }    }    else    {        DSPLogUARTSwitchOff ();    }#endif    if (RESTART_BY_ALARM == POWER_GetRestartCondition())    {        if (!TM_IsAlarmExpired())        {            //if it is a invalid alarm int, we need to reset the condition to RESTART_BY_NONE status,             //and next it will enter into USB MCFT mode            POWER_SetRestartCondition(RESTART_BY_NONE);        }    }    if(RESTART_BY_NONE == POWER_GetRestartCondition())    {#ifndef FPGA_VERIFICATION                 /*enter into USB MCFT Mode*/        RM_GetVcomRunMode();#endif        /*        * In this period, we may enter into calibration mode        * or pwr key,charge,alarm conditon is meet.        * so should save restart condition again.        */        SaveSWRestartCondition();    }     mode = POWER_GetResetMode();#ifndef WIN32    if(mode == CALIBRATION_NV_ACCESS_MODE)    {        /*nv write access mode,write imei*/        RM_Cali_NvAccess();    }    // Switch ARM log according to NV flag setting    SCI_InitLogSwitch(REFPARAM_GetEnableArmLogFlag());    // In test mode we close ARM log    if ((RM_GetPinTestFlag())||  POWER_IsCalibrationResetMode( ))    {        SCI_InitLogSwitch(SCI_FALSE);    }    m_dcb.baud_rate     = SIO_GetBaudRate(COM_DEBUG);    if( POWER_IsCalibrationResetMode() )    {        if(1 == RM_GetDloaderMode())        {            /*for USB MCFT*/            debug_phy_port  = VIR_COM0;        }        else        {          #if defined(DPHONE_SUPPORT) || defined(CALI_MODE_PORT_UART0)                       /*uart cft mode, default:uart0, 115200*/            debug_phy_port  = COM0;          #else            /*uart cft mode, default:uart1, 115200*/            debug_phy_port  = COM1;          #endif                  REFPARAM_SetDebugPortPhyNo(debug_phy_port);            m_dcb.baud_rate = 0x71;        }    }    else    {        debug_phy_port      = REFPARAM_GetDebugPortPhyNo();    }    m_dcb.flow_control   = 0;    /* creat COM_DEBUG */    SIO_Create(COM_DEBUG, debug_phy_port, &m_dcb);    /*init sio log buffer first*/    SIO_ResetBuf(COM_DEBUG);    /* creat COM_DATA */    data_phy_port        = REFPARAM_GetDataPortPhyNo();    m_dcb.baud_rate      = SIO_GetBaudRate(COM_DATA);#ifndef MUX_SUPPORT    SIO_Create(COM_DATA, data_phy_port, &m_dcb);#else    if( POWER_IsCalibrationResetMode() )    {        SIO_Create(COM_DATA, data_phy_port, &m_dcb);    }    else    {      #ifdef UART0_HWFLOW_SUPPORT        m_dcb.flow_control = HW_FLOW_CONTROL;      #endif                MUX_Create(COM_DATA, data_phy_port, &m_dcb);        #ifdef DUAL_MUX_SUPPORT               MUX_Create(COM_DATA2, REFPARAM_GetData2PortPhyNo(), &m_dcb);        #endif        /*important, mux and sio share same port, so we should disable sio port when using mux func*/        SIO_Create(COM_DATA, 0xff, &m_dcb);    }#endif        #if defined(PRODUCT_DM)    SCI_InitRtosBottomHalf( );#endif    // Set log filters.    SCI_InitLogFilter();    // Init IRAM collision manager     area_p = GetIRAMSet(&iram_area_cnt);    if ((SCI_NULL != area_p) && (iram_area_cnt))    {        IRAM_Init (area_p, iram_area_cnt);    }    else    {        //SCI_TRACE_LOW:"\r\nSCI_InitRef: IRAM mgr fail to register"        SCI_TRACE_ID(TRACE_TOOL_CONVERT,INIT_556_112_2_18_1_5_20_30,(uint8*)"");    }    // Check if need power on.    tmp = POWER_GetRestartCondition();    if (RESTART_BY_NONE == tmp)    {        if (REFPARAM_GetAutoPowerOnFlag())        {            // This function must be called after EFS_Init().            POWER_SetRestartCondition(RESTART_BY_SOFTWARE);        }        else        {                  HAL_TurnOffPower();        }    }    else if ( RESTART_BY_POWER_BUTTON == tmp)    {        if ( IsPowerButtonReleased() )        {            // we need check the charge status.            // when the charge is connect, If the user press the button before check             // the restart condition and release it before check the power button here.            // System will power down.             // But we want the system will restart by charge.            if( CHGMNG_IsChargeConnect() )            {                // The charge is in, need reset the restart condition.                // and power on                POWER_SetRestartCondition( RESTART_BY_CHARGE );            }            else            {                HAL_TurnOffPower();            }        }    }    else if ( RESTART_BY_CHARGE == tmp)//for auto test     {         if (REFPARAM_GetAutoPowerOnFlag())         {            POWER_SetAutoTestMode();/*lint !e746*/         }       if (POWER_IsAutoTestMode())       {          // This function must be called after EFS_Init().          POWER_SetRestartCondition(RESTART_BY_SOFTWARE);       }        }    // Phase3 of chip driver intialization. It initializes driver modules     // after refbase confirms powering on.    CHIPDRV_InitOnPhase3 ();#ifdef MODEM_PLATFORM #ifdef UMEM_SUPPORT    if(0xFFFFFFFF != (uint32)FLASH_GetUmemAddr())        {                    if( ( CALIBRATION_POST_MODE != mode)&& \                ( CALIBRATION_MODE != mode) &&  \                ( CALIBRATION_POST_NO_LCM_MODE != mode))            {                Umem_RegBSD();            }      }    SFS_Init(0);#endif#endif#ifndef MODEM_PLATFORM#ifdef SPLOAD_ENABLE    {        extern void LCM_Sensor_SperateBin_Init(void);        LCM_Sensor_SperateBin_Init();    }#endif#ifndef NANDBOOT_SUPPORT    #ifdef UMEM_SUPPORT        if(0xFFFFFFFF != (uint32)FLASH_GetUmemAddr())        {                    if( ( CALIBRATION_POST_MODE != mode)&& \                ( CALIBRATION_MODE != mode) &&  \                ( CALIBRATION_POST_NO_LCM_MODE != mode))            {                Umem_RegBSD();            }        }    #endif#endif#ifdef IMG_EDITER_SUPPORT    IMGPROC_Init(NULL);#endif        ISP_ServiceInit();    LCD_Init();     switch(mode)    {        case WATCHDOG_RESET_MODE:        case EXTERNAL_RESET_MODE:             /* Set to RESTART_BY_ASSERT condition in order to MMI handle.*/            POWER_SetRestartCondition(RESTART_BY_ASSERT);            //no break;           case ASSERT_BACK_MODE:    /*lint !e825*/            if(!BOOT_GetBLStatus())  //bl is turn off            {                 LCD_Clear(MAIN_LCD_ID, 0x00);            }            break;        default:            break;    }    IMG_DEC_Init();#endif    // Export interface for external user setting    // For the product parameter initialization    // After that welcome logo will be showed    PROD_Init();    //set the init status to STATUS_FINISH_PROD_INIT    INIT_SetInitStatus(STATUS_FINISH_PROD_INIT);#ifndef MODEM_PLATFORM    _INIT_CopyImage();#endif    // Phase4 of chip driver intialization. It initializes MMU after     // refbase has copied the kernel image.    CHIPDRV_InitOnPhase4 ();#ifdef DSP_USB_LOG    SIO_DSP_LOG_Info_Notify();    if (DSP_LOG_ARM_COM_DEBUG == REFPARAM_GetDspDebugPortPhyNo())     {        /*init DSP IRQ*/    if (TB_SUCCESS == ISR_RegHandler(TB_DSP_INT1, (TB_ISR)SIO_DSP_ISR_Handler))    {            *(volatile uint32 *)(GR_ICLR) |= 0x04;  //Clear DSP IRQ1        TB_DisableFIQ(TB_DSP_INT1);        TB_EnableINT(TB_DSP_INT1);    }        SIO_DspLogUSBEnableSet(TRUE);    SIO_CreateDSPLogThread();    }    else   {        SIO_DspLogUSBEnableSet(FALSE);   }#endif#else    IMG_DEC_Init();#endif  /*WIN32*/  #ifdef PRJ_TDPS_UEIT_MMI    SCI_InitRtosBottomHalf( );#endif    PROD_InitByStep(PROD_INIT_AFTER_USER_IMAGE);    // Initialize audio.    AUD_Init();     //charge server & do idle on page init     DoIdle_Init( );    // this depend on nothing.    // Create reference thread.    CreateRefTasks(mode);#ifdef DEMOD_HW_INNOFIDEI#ifndef WIN32    INNO_DoDemodLowPowerMode();#endif#endif#ifndef MODEM_PLATFORM    SFS_Init(0);#endif    // Display version information by trace msg    ShowVersionInfo();    //CheckNVVersion();#ifndef  WIN32    REF_CheckCalibrationParamVersion(REF_GetCalibrationParamVersion());    REF_CheckDownloadParamVersion(REF_GetDownloadParamVersion());#endif #ifdef  WIN32    CHR_Init();    // The parameter hasnot been download to the module,    // it will failed reading from flash. And it need write data to flash at here.    // So it should be called after EFS task created.    // These two functions must be called after EFS_Init().    OSPARAM_InitOsParam();    REFPARAM_InitRefParam();        // Set log filters.    SCI_InitLogFilter();#endif  // WIN32 #ifndef WIN32    #ifdef AUTOTEST_DEVICE_SUPPORT        Register_DeviceAutoTest_CmdRoutine();    #endif#endif       POWER_SetMsStatus(POWER_MS_STATUS_POWER_OFF);#ifndef  WIN32    #ifdef VT_SUPPORT        $Super$$__cpp_initialise();  /*lint !e27 */    #endif   #endif#ifndef WIN32    #ifdef CMMB_SUPPORT        // Init CMMB test thread        if (RM_GetCalibrationMode())        {            DTLRFVT_ThreadInit();        }        // Init V log To BB flag        MTV_InitVLogFlag();    #endif#endif    //JavaEntry(0, NULL);    //RmtMain_start();    return SCI_SUCCESS;}/*****************************************************************************/// Description :    Initialize Hardware.//                  Include ISR, clock, timer, RTC, serial port.// Global resource dependence : // Author :         Richard.Yang// Note :/*****************************************************************************/PUBLIC void SCI_InitHw(void){}/*****************************************************************************/// Description :   Show Version information// Global resource dependence : // Author :         // Note :/*****************************************************************************/LOCAL void ShowVersionInfo(){#ifndef WIN32    const   char * info_ptr = NULL;    uint32 t = 0;    uint32 num = VERSION_GetInfoNum();    //SCI_TRACE_LOW:"\r\n============Version Information=============\r\n"    SCI_TRACE_ID(TRACE_TOOL_CONVERT,INIT_793_112_2_18_1_5_20_31,(uint8*)"");    for(t = 0; t < num; t++)    {        info_ptr = VERSION_GetInfo(t);        if(info_ptr)        {           SCI_TRACE_LOW(info_ptr);         }    }    // Show RTOS build time!    info_ptr = SCI_GetRtosCompileDate();    //SCI_TRACE_LOW:"RTOS Compile Date : %s"    SCI_TRACE_ID(TRACE_TOOL_CONVERT,INIT_803_112_2_18_1_5_20_32,(uint8*)"s", info_ptr);    // Show Ref build time!    info_ptr = GetRefCompileDate();    //SCI_TRACE_LOW:"REF Compile Date : %s"    SCI_TRACE_ID(TRACE_TOOL_CONVERT,INIT_807_112_2_18_1_5_20_33,(uint8*)"s", info_ptr);    //SCI_TRACE_LOW:"\r\n=============================================\r\n"    SCI_TRACE_ID(TRACE_TOOL_CONVERT,INIT_809_112_2_18_1_5_20_34,(uint8*)"");#endif}/*****************************************************************************/// Description :    Create reference tasks.// Global resource dependence : // Author :         Xueliang.Wang// Note :/*****************************************************************************/LOCAL int CreateRefTasks(uint32 mode){    switch(mode)    {        case CALIBRATION_MODE:        case LAYER1_TEST_MODE:        case DSP_CODE_DOWNLOAD_BACK_CALIBRATION:            STATIC_TASK_CREATE(Cal);            break;        case CALIBRATION_POST_NO_LCM_MODE:#ifndef WIN32            STATIC_TASK_CREATE(CalNoApp);#endif                    break;        default:            STATIC_TASK_CREATE(Normal);    }    return SCI_SUCCESS;}/*****************************************************************************/// Description:    The function is to define the user's initialization //                  function. User implement this function.// Global resource dependence:// Author:         Xueliang.Wang// Note:/*****************************************************************************/PUBLIC void SCI_ApplicationDefine(void *first_unused_memory){    uint16    reset_mode;#ifndef WIN32    //set the init status to STATUS_START_INIT    INIT_SetInitStatus(STATUS_START_INIT);#ifdef UART1_PIN_SEL_UART1_1 // sdio pin    // SD's UART1 port should be EN_SDIO_LDO() in power_cfg.c before use    LDO_Init();    LDO_Prod_Init();#endif    // Split the function (RM_GetRunMode) into two parts    RM_SendRunModeRequest ();    /* Save restart condition.*/    SaveHWRestartCondition();#endif    /* Initialize RTOS.     */    SCI_InitRtos();    /* Initialize Reference.*/    SCI_InitRef(0);    #ifdef CARD_LOG#ifndef WIN32    SCI_InitLogSaveTask();#endif#endif#ifndef WIN32       reset_mode = POWER_GetResetMode();      switch(reset_mode)    {        case CALIBRATION_MODE:        case DSP_CODE_DOWNLOAD_BACK_CALIBRATION:            /* Start Calibration resource.*/            SCI_InitAtc();            L1API_SCI_StartCalibration();            break;        case LAYER1_TEST_MODE:            /* Start Layer test resource.*/                  SCI_StartLayer1Test();            break;        case ASSERT_BACK_MODE:            SCI_WriteAssertInfoToNv();  //@Johnson.sun write assert Info to NV 2006/11/13               /* Power On automatically. */               POWER_PowerOn();            break;        case WATCHDOG_RESET_MODE:            /* Wirte watchdog reset info to nv */             SCI_WriteWatchdogResetInfoToNv();             /* Power On automatically. */             POWER_PowerOn();            break;        default:            /* Power On automatically. */            POWER_PowerOn();    }    BOOT_InitResetMode ();#else   /* not define WIN32 */    /* Power On automatically.*/    POWER_PowerOn();#endif  /* WIN32 */	}/**---------------------------------------------------------------------------* **                         Compiler Flag                                     * **---------------------------------------------------------------------------*/#ifdef   __cplusplus    }#endif //